---
title: 哈希算法，打造安全的密码体制
date: 2016-10-12 17:37:38
tags:
---

## 前言

本文主要讨论了哈希算法的应用，而没有涉及非对称加密，对称加密等密码学的算法，但是还是先解释下密码学中的一些基础概念：

**密钥**：分为加密密钥和解密密钥。  
**明文**：没有进行加密，能够直接代表原文含义的信息。  
**密文**：经过加密处理处理之后，隐藏原文含义的信息。  
**加密**：将明文转换成密文的实施过程。  
**解密**：将密文转换成明文的实施过程。  
**密码算法**：密码系统采用的加密方法和解密方法，随着基于数学密码技术的发展，加密方法一般称为加密算法，解密方法一般称为解密算法。   
**公开密钥加密**（public-key cryptography，又译为公开密钥加密），也称为非对称加密（asymmetric cryptography），一种密码学算法类型，在这种密码学方法中，需要一对密钥，一个是私人密钥，另一个则是公开密钥。这两个密钥是数学相关，用某用户密钥加密后所得的信息，只能用该用户的解密密钥才能解密。如果知道了其中一个，并不能计算出另外一个。因此如果公开了一对密钥中的一个，并不会危害到另外一个的秘密性质。称公开的密钥为公钥；不公开的密钥为私钥。RSA 是常见的公钥加密算法。  
**对称密钥加密**（Symmetric-key algorithm）又称为对称加密、私钥加密、共享密钥加密，是密码学中的一类加密算法。这类算法在加密和解密时使用相同的密钥，或是使用两个可以简单地相互推算的密钥。实务上，这组密钥成为在两个或多个成员间的共同秘密，以便维持专属的通讯联系。与公开密钥加密相比，要求双方取得相同的密钥是对称密钥加密的主要缺点之一。常见的对称加密算法有 DES、3DES、AES 等

## Base64

Base64 是一种基于64个可打印字符来表示二进制数据的表示方法。
即小写字母 a-z、大写字母 A-Z、数字 0-9、符号 "+"、"/"（再加上作为垫字的 "="，实际上是65个字符）作为一个基本字符集。然后，其他所有符号都转换成这个字符集中的字符。

具体来说，转换方式可以分为四步。

- 将每三个字节作为一组，一共是24个二进制位。  
- 将这24个二进制位分为四组，每个组有6个二进制位。  
- 在每组前面加两个00，扩展成32个二进制位，即四个字节。  
- 根据 Base64 索引表，得到扩展后的每个字节的对应符号，这就是 Base64 的编码值。  

![](http://7xq3d5.com1.z0.glb.clouddn.com/base64.png)
第一步，"M"、"a"、"n"的 ASCII 值分别是77、97、110，对应的二进制值是01001101、01100001、01101110，将它们连成一个24位的二进制字符串010011010110000101101110。
第二步，将这个24位的二进制字符串分成4组，每组6个二进制位：010011、010110、000101、101110。
第三步，在每组前面加两个00，扩展成32个二进制位，即四个字节：00010011、00010110、00000101、00101110。它们的十进制值分别是19、22、5、46。
第四步，根据上表，得到每个值对应Base64编码，即T、W、F、u。


	var encodedData = window.btoa("Hello, world"); // 编码
	var decodedData = window.atob(encodedData); // 解码

**注意**：Base64 只是一种编码方式，并不是一种加密算法，不要使用 Base64 来加密数据。

## 哈希算法

![hash](http://7xq3d5.com1.z0.glb.clouddn.com/2000px-Hash_table_4_1_1_0_0_1_0_LL.svg.png)

哈希算法并不是一个特定的算法而是一类算法的统称。哈希算法也叫散列算法，一般来说满足这样的关系：f(data)=key，输入任意长度的 data 数据，经过哈希算法处理后输出一个定长的数据 key。同时这个过程是**不可逆**的，无法由 key 逆推出 data。

如果是一个 data 数据集，经过哈希算法处理后得到key的数据集，然后将 keys 与原始数据进行一一映射就得到了一个哈希表。一般来说哈希表 M 符合 M[key]=data 这种形式。
哈希表的好处是当原始数据较大时，我们可以用哈希算法处理得到定长的哈希值 key，那么这个 key 相对原始数据要小得多。我们就可以用这个较小的数据集来做索引，达到快速查找的目的。

稍微想一下就可以发现，既然输入数据不定长，而输出的哈希值却是固定长度的，这意味着哈希值是一个有限集合，而输入数据则可以是无穷多个。那么建立一对一关系明显是不现实的。**所以"碰撞"(不同的输入数据对应了相同的哈希值)是必然会发生的**，所以一个成熟的哈希算法会有较好的抗冲突性。同时在实现哈希表的结构时也要考虑到哈希冲突的问题。

密码上常用的 MD5，SHA 都是哈希算法，因为 key 的长度(相对大家的密码来说)较大所以碰撞空间较大，有比较好的抗碰撞性，所以常常用作密码校验。

抗碰撞性使哈希算法对原始输入的任意一点更改，都会导致产生不同的哈希值，因此哈希算法可以用来检验数据的完整性。我们经常见到在一些网站下载某个文件时，网站还提供了此文件的哈希值，以供我们下载文件后检验文件是否被篡改。

不可逆的特性使哈希算法成为一种单向密码体制，只能加密不能解密，可以用来加密用户的登录密码等凭证。

## 消息摘要算法

哈希函数的抗冲突性使得如果一段明文稍有变化，哪怕只更改该段落的一个字母，通过哈希算法作用后都将产生不同的值。而哈希算法的单向性使得要找到哈希值相同的两个不同的输入消息，在计算上是不可能的。所以数据的哈希值，即消息摘要，可以检验数据的完整性。

消息摘要算法的主要特征是加密过程不需要密钥，并且经过加密的数据无法被解密，只有输入相同的明文数据经过相同的消息摘要算法才能得到相同的密文。

现在，消息摘要算法主要应用在“数字签名”领域，作为对明文的摘要算法。著名的摘要算法有RSA公司的MD5算法和SHA-1算法及其大量的变体。

## MD5消息摘要算法

MD5消息摘要算法（MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。

![md5](http://7xq3d5.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-12%2014.47.49.png)


## SHA安全散列算法
安全散列算法（Secure Hash Algorithm）是一个密码散列函数家族，是FIPS所认证的五种安全散列算法。能计算出一个数字消息所对应到的，长度固定的字符串（又称消息摘要）的算法。

	String string="SHA加密";
	        BigInteger sha;
	        System.out.println("加密前的数据:" + string);
	        byte[] inputData = string.getBytes();
	        try {
	            MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
	            messageDigest.update(inputData);
	            sha = new BigInteger(messageDigest.digest());
	            System.out.println("SHA加密后的数据:" + sha.toString(32));
	        } catch (Exception e) {
	            e.printStackTrace();
	        }

## 打造安全的密码体制

### 哈希：不可逆加密
密码加密不同于普通的加密，一是内容重要，二是密码的验证根本不需要原文，要检查一个密码是否正确，只需要看它加密的结果与正确的密码加密的结果是否一致即可。确定了这两点，对于加密的方法，就只要求同一个字符串加密后会得到同样的密文。哈希完全满足了这一要求。

在哈希算法中，首选是 SHA2 系列，虽然安全性由于 SHA1 的原因而被质疑，但至少目前还没有证明有什么纰漏。MD5 由于用得太多，而且[彩虹表](https://zh.wikipedia.org/wiki/%E5%BD%A9%E8%99%B9%E8%A1%A8)实在过于泛滥，并不推荐使用。

另外一个问题，哈希一遍是不是就够了呢？当然不，不仅要多次哈希，而且还要与用户名一类的数据混加，比如，可以使用下面的方式来在客户端加密原始密码：

	sha256(
	  sha265(sha265(password)) + sha265(username)
	)
这样，不仅可以增加密文反推原文的难度，还加入用户名，使得就算密码相同，不同用户的密文也完全不一样。

在客户端的加密，基本上也就只能到这一步了，因为一个最主要的问题是，客户端的加密算法是公开的。客户端加密的目的，在于保护用户的原始密码，不是为了防止被窃。


### 盐：混入随机数据

虽然在客户端对密码进行了加密，但无论是算法，还是混入的用户名，都是公开了的。剩下的加密，就需要留给后端了。

由于对同一字符串进行哈希的结果是恒定的，所以知道了算法和密文，理论上是可以反推出密码的，反推的难度取决于用户原始密码的复杂度。那如何才能够让反推的难度指数级增大呢？答案是在原始密码密文的基础之上，再加入一个随机字符串，从而达到让用户的密码更复杂的效果。这个随机字符串，便是盐。

后端获取到客户端传来的密码之后，再通过加盐哈希进行再加密。比如像下面这样：

	sha256(
	  sha256(username + sha256(password + salt)) + salt + sha256(username + salt)
	)
	
注意，盐的保存非常关键，务必将它与用户信息分开存放。

### HTTPS

在 HTTP 协议下，数据是明文传输，传输过程中网络嗅探可直接获取其中的数据。 如用户的密码和信用卡相关的资料，一旦被中间人获取，会给用户带来极大的安全隐患。

另一方面，在非加密的传输过程中，攻击者可更改数据或插入恶意的代码等。HTTPS 的诞生就是为了解决中间人攻击的问题，但如今 HTTPS 的使用情况在国内并不乐观，基本是因为成本或者性能的考量。


参考资料：

[密码学-wikipedia](https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A0%81%E5%AD%A6)   
[散列函数-wikipedia](https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8)  
[MD5-wikipedia](https://zh.wikipedia.org/zh-sg/MD5)  
[SHA家族-wikipedia](https://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F)  
[什么是哈希表和哈希算法？](http://www.guokr.com/question/562532/)  
[如何安全地保存用户的密码](https://xts.so/database/how-to-keep-users-password-secure.html)  
[打造一个安全的用户名密码登录系统](http://chensd.com/2016-08/Safe-username-password-Login-System.html)  
[为什么说 MD5 是不可逆的？](https://www.zhihu.com/question/22651987)  
[Web前端密码加密是否有意义？](https://www.zhihu.com/question/25539382)  
[如何保证用户登录时提交密码已经加密？](https://www.zhihu.com/question/20060155)  
[什么是哈希算法？](https://www.zhihu.com/question/20820286)  
[Android应用安全开发之浅谈加密算法的坑](https://jaq.alibaba.com/community/art/show?articleid=209)  
[密码学笔记](http://www.ruanyifeng.com/blog/2006/12/notes_on_cryptography.html)  
[Base64笔记](http://www.ruanyifeng.com/blog/2008/06/base64.html)  
[Android安全开发之安全使用HTTPS](https://zhuanlan.zhihu.com/p/22816331)  
[Android安全之Https中间人攻击漏洞](http://yaq.qq.com/blog/13)  
[加解密（Encryption）& 哈希（Hash）算法----入门指引](https://zhuanlan.zhihu.com/p/20064358)